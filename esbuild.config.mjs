import esbuild from 'esbuild';
import process from 'process';
import builtins from 'builtins';
import fs from 'fs';
import path from 'path';
import postcss from 'esbuild-postcss';
import tailwindcss from 'tailwindcss';
import autoprefixer from 'autoprefixer';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const buildMode = process.argv[2] || 'dev';
const isProd = buildMode === 'production' || buildMode === 'libs';

let deployDir = '';
try {
    const buildConfig = JSON.parse(fs.readFileSync('build.json', 'utf8'));
    if (buildConfig.deployPath) {
        deployDir = buildConfig.deployPath;
    }
} catch (error) {
    // build.json doesn't exist or is invalid, ignore deployment
}

const baseConfig = {
    bundle: true,
    target: 'es2018',
    logLevel: 'info',
    sourcemap: isProd ? false : 'inline',
    treeShaking: true,
    minify: isProd,
    allowOverwrite: true,
};

async function copyDir(src, dest) {
    await fs.promises.mkdir(dest, { recursive: true });
    const entries = await fs.promises.readdir(src, { withFileTypes: true });

    for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);

        entry.isDirectory() ?
            await copyDir(srcPath, destPath) :
            await fs.promises.copyFile(srcPath, destPath);
    }
}

async function deployPlugin() {
    if (!isProd || !deployDir) return;
    console.log(`Deploying plugin to ${deployDir}...`);
    try {
        await fs.promises.rm(deployDir, { recursive: true, force: true });
        await copyDir('Dist', deployDir);
        console.log(`\n================================`);
        console.log(` √√√√√√  Plugin Deployed!`);
        console.log(`   Source: Dist/`);
        console.log(`   Destination: ${deployDir}`);
        console.log(`==================================\n`);
    } catch (err) {
        console.error('Error during deployment:', err);
    }
}

const buildPlugin = () => {
    const cssStringPlugin = {
        name: 'css-string',
        setup(build) {
            build.onResolve({ filter: /^css-string:/ }, args => {
                return {
                    path: args.path.slice('css-string:'.length),
                    namespace: 'css-string',
                    pluginData: {
                        resolveDir: args.resolveDir,
                    },
                };
            });

            build.onLoad({ filter: /.*/, namespace: 'css-string' }, async args => {
                const filePath = path.join(args.pluginData.resolveDir, args.path);
                const content = await fs.promises.readFile(filePath, 'utf8');
                return {
                    contents: `export default ${JSON.stringify(content)};`,
                    loader: 'js',
                };
            });
        },
    };

    const pluginConfig = {
        ...baseConfig,
        banner: {
            js: banner,
        },
        entryPoints: ['src/main.ts'],
        external: [
            'obsidian',
            'electron',
            '@codemirror/autocomplete',
            '@codemirror/collab',
            '@codemirror/commands',
            '@codemirror/language',
            '@codemirror/lint',
            '@codemirror/search',
            '@codemirror/state',
            '@codemirror/view',
            '@lezer/common',
            '@lezer/highlight',
            '@lezer/lr',
            'mathjax-full/*',
            ...builtins()
        ],
        format: 'cjs',
        outfile: 'Dist/main.js',
        loader: { '.ts': 'tsx' },
        plugins: [
            cssStringPlugin,
            postcss({
                plugins: [tailwindcss, autoprefixer],
            }),
        ],
    };

    const cssConfig = {
        ...baseConfig,
        entryPoints: ['src/styles/index.css'],
        outfile: 'Dist/styles.css',
        plugins: [
            postcss({
                plugins: [tailwindcss, autoprefixer],
            }),
        ],
    };

    const buildPromises = [
        esbuild.build(pluginConfig),
        esbuild.build(cssConfig),
    ].map(p => p.catch(() => process.exit(1)));


    if (isProd) {
        Promise.all(buildPromises).then(async () => {
            await fs.promises.copyFile('manifest.json', 'Dist/manifest.json');
            await copyDir('assets', 'Dist/assets');
        });
    } else if (buildMode === 'watch') {
        pluginConfig.watch = { 
            onRebuild: (err) => {
                if (err) {
                    console.error(err)
                } else {
                    console.log('Rebuild complete, skipping deployment in watch mode.');
                }
            }
        };
        cssConfig.watch = { 
            onRebuild: (err) => {
                if (err) {
                    console.error(err)
                } else {
                    console.log('CSS rebuild complete.');
                }
            }
        };
        esbuild.build(pluginConfig).catch(() => process.exit(1));
        esbuild.build(cssConfig).catch(() => process.exit(1));
    }
};

const buildLibs = () => {
    // Copy mermaid library from node_modules
    const mermaidSrc = './node_modules/mermaid/dist/mermaid.min.js';
    const mermaidDest = 'Dist/mermaid.js';
    fs.copyFile(mermaidSrc, mermaidDest, (err) => {
        if (err) {
            console.error('Error copying mermaid library:', err);
            process.exit(1);
        }
        console.log('Mermaid library copied successfully.');
    });

    // Build mathjax library - use CDN version to avoid require issues
    fs.writeFileSync('mathjax-entry.js', `
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
        (function() {
            var script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
            script.async = true;
            document.head.appendChild(script);
        })();
    `);
    esbuild.build({
        ...baseConfig,
        entryPoints: ['mathjax-entry.js'],
        outfile: 'Dist/mathjax.js',
        format: 'iife',
        platform: 'browser',
    }).then(() => {
        fs.unlinkSync('mathjax-entry.js');
    }).catch(() => {
        fs.unlinkSync('mathjax-entry.js');
        process.exit(1)
    });
    
    const highlightStylesSrc = './node_modules/highlight.js/styles';
    const highlightStylesDest = './Dist/assets/codestyle';

    fs.readdir(highlightStylesSrc, (err, files) => {
        if (err) {
            console.error('Error reading highlight.js styles directory:', err);
            process.exit(1);
        }

        if (!fs.existsSync(highlightStylesDest)){
            fs.mkdirSync(highlightStylesDest, { recursive: true });
        }

        files.forEach(file => {
            if (file.endsWith('.css') && !file.endsWith('.min.css')) {
                const srcPath = `${highlightStylesSrc}/${file}`;
                const destPath = `${highlightStylesDest}/${file}`;
                fs.copyFile(srcPath, destPath, (err) => {
                    if (err) {
                        console.error(`Error copying ${file}:`, err);
                    }
                });
            }
        });
        console.log('Highlight.js styles copied successfully.');
    });
};

if (buildMode === 'libs') {
    buildLibs();
} else if (buildMode === 'deploy') {
    deployPlugin();
} else {
    buildPlugin();
}