import esbuild from 'esbuild';
import process from 'process';
import builtins from 'builtins';
import fs from 'fs';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const buildMode = process.argv[2] || 'dev';
const isProd = buildMode === 'production' || buildMode === 'libs';

const baseConfig = {
    bundle: true,
    target: 'es2018',
    logLevel: 'info',
    sourcemap: isProd ? false : 'inline',
    treeShaking: true,
    minify: isProd,
    allowOverwrite: true,
};

const cssPlugin = {
    name: 'css-loader',
    setup(build) {
        build.onLoad({ filter: /\.css$/ }, async (args) => {
            const css = await fs.promises.readFile(args.path, 'utf8');
            return {
                contents: css,
                loader: 'text',
            };
        });
    },
};

const buildPlugin = () => {
    const pluginConfig = {
        ...baseConfig,
        banner: {
            js: banner,
        },
        entryPoints: ['main.ts'],
        external: [
            'obsidian',
            'electron',
            '@codemirror/autocomplete',
            '@codemirror/collab',
            '@codemirror/commands',
            '@codemirror/language',
            '@codemirror/lint',
            '@codemirror/search',
            '@codemirror/state',
            '@codemirror/view',
            '@lezer/common',
            '@lezer/highlight',
            '@lezer/lr',
            'mathjax-full/*',
            ...builtins()
        ],
        format: 'cjs',
        outfile: 'main.js',
        plugins: [cssPlugin],
    };

    if (buildMode === 'watch') {
        pluginConfig.watch = { onRebuild: (err) => err && console.error(err) };
    }

    esbuild.build(pluginConfig).catch(() => process.exit(1));
};

const buildLibs = () => {
    // Copy mermaid library from node_modules
    const mermaidSrc = './node_modules/mermaid/dist/mermaid.min.js';
    const mermaidDest = 'mermaid.js';
    fs.copyFile(mermaidSrc, mermaidDest, (err) => {
        if (err) {
            console.error('Error copying mermaid library:', err);
            process.exit(1);
        }
        console.log('Mermaid library copied successfully.');
    });

    // Build mathjax library - use CDN version to avoid require issues
    fs.writeFileSync('mathjax-entry.js', `
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
        (function() {
            var script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
            script.async = true;
            document.head.appendChild(script);
        })();
    `);
    esbuild.build({
        ...baseConfig,
        entryPoints: ['mathjax-entry.js'],
        outfile: 'mathjax.js',
        format: 'iife',
        platform: 'browser',
    }).then(() => {
        fs.unlinkSync('mathjax-entry.js');
    }).catch(() => {
        fs.unlinkSync('mathjax-entry.js');
        process.exit(1)
    });
    
    const highlightStylesSrc = './node_modules/highlight.js/styles';
    const highlightStylesDest = './assets/style';

    fs.readdir(highlightStylesSrc, (err, files) => {
        if (err) {
            console.error('Error reading highlight.js styles directory:', err);
            process.exit(1);
        }

        files.forEach(file => {
            if (file.endsWith('.css')) {
                const srcPath = `${highlightStylesSrc}/${file}`;
                const destPath = `${highlightStylesDest}/${file}`;
                fs.copyFile(srcPath, destPath, (err) => {
                    if (err) {
                        console.error(`Error copying ${file}:`, err);
                    }
                });
            }
        });
        console.log('Highlight.js styles copied successfully.');
    });
};

if (buildMode === 'libs') {
    buildLibs();
} else {
    buildPlugin();
}